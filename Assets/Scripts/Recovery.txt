using System.Collections.Generic;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public class Test2 : MonoBehaviour
{
    public PeelingMesh peelingMesh;

    public NativeArray<float3> vertices;
    public Vector2[] uvs;
    public Vector2[] uvs2;
    public NativeArray<int> triangles;

    public Mesh mesh;

    Dictionary<int, int[]> dic = new Dictionary<int, int[]>();

    List<int[]> list = new List<int[]>();

    NativeArray<Data> datas;

    NativeList<int> sameIndices;

    private void Start()
    {
        MeshFilter meshFilter = GetComponent<MeshFilter>();
        uvs = meshFilter.mesh.uv;
        uvs2 = meshFilter.mesh.uv;

        Vector3[] _vertices = meshFilter.mesh.vertices;
        vertices = new NativeArray<float3>(_vertices.Length, Allocator.Persistent);
        for (int i = 0; i < vertices.Length; i++) vertices[i] = _vertices[i];


        int[] _triangles = meshFilter.mesh.triangles;
        triangles = new NativeArray<int>(_triangles.Length, Allocator.Persistent);
        for (int i = 0; i < triangles.Length; i++) triangles[i] = _triangles[i];

        mesh = meshFilter.mesh;

        sameIndices = new NativeList<int>(Allocator.Persistent);
        datas = new NativeArray<Data>(triangles.Length, Allocator.Persistent);
        // for (int i = 0; i < datas.Length; i++)
        // {
        //     datas[i] = new Data(new NativeList<int>());
        // }

        SameVerticesJob sameVerticesJob = new SameVerticesJob()
        {
            vertices = vertices,
            datas = datas,
            triangles = triangles,
            sameIndices = sameIndices
        };

        // JobHandle jobHandle = sameVerticesJob.ScheduleParallel(triangles.Length, 1024, default);
        JobHandle jobHandle = sameVerticesJob.Schedule(triangles.Length, default);
        jobHandle.Complete();

        Debug.Log(datas.Length);
        for (int i = 0; i < 100; i++)
        {
            Debug.Log(datas[i]);
        }

        // for (int i = 0; i < triangles.Length; i++)
        // {
        //     Vector3 v = vertices[datas[i].indices[0]];
        //     for (int j = 0; j < datas[i].indices.Length; j++)
        //     {
        //         vertices[datas[i].indices[j]] = v;
        //     }
        // }
    }

    // private void Update()
    // {
    //     Debug.Log(datas.Length);
    //     for (int i = 0; i < 100; i++)
    //     {
    //         Debug.Log(datas[i]);
    //     }
    // }

    [BurstCompile]
    public struct SameVerticesJob : IJobFor
    {
        [ReadOnly] public NativeArray<float3> vertices;
        [WriteOnly] public NativeArray<Data> datas;
        [ReadOnly] public NativeArray<int> triangles;
        public NativeList<int> sameIndices;

        public void Execute(int index)
        {
            int startIndex = sameIndices.Length - 1;
            float3 v = vertices[triangles[index]];
            for (int j = 0; j < triangles.Length; j++)
            {
                float sqrDst = math.distancesq(v, vertices[triangles[j]]);
                if (sqrDst < .001f)
                {
                    sameIndices.Add(triangles[j]);
                }
            }

            datas[index] = new Data(startIndex, sameIndices.Length - startIndex);
        }
    }
}

// public struct Data
// {
//     public int[] indices;

//     public Data(NativeList<int> listIndices)
//     {
//         indices = new int[listIndices.Length];
//         // for (int i = 0; i < indices.Length; i++) indices[i] = listIndices[i];
//     }
// }

[BurstCompile]
public struct Data
{
    // public NativeArray<int> indices;
    public int startIndex;
    public int indicesLength;

    public Data(int startIndex, int indicesLength)
    {
        this.startIndex = startIndex;
        this.indicesLength = indicesLength;
    }
}